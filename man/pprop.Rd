% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pprop.R
\name{pprop}
\alias{as.character.pprop}
\alias{as.double.pprop}
\alias{pprop}
\title{Approximations of proportions that look pretty and are easy to describe in words.}
\usage{
pprop(prop, char = getOption("pprop.char"),
  char.method = getOption("pprop.char.method"),
  fixed.divisors = getOption("pprop.fixed.divisors"),
  simple.signif.digits = getOption("pprop.simple.signif.digits"),
  simple.max.num = getOption("pprop.simple.max.num"),
  h = getOption("pprop.h"))

\method{as.character}{pprop}(x, char.method = getOption("pprop.char.method"),
  ...)

\method{as.double}{pprop}(x, ...)
}
\arguments{
\item{prop}{A proportion or vector of proportions. Must be between 0 and 1.}

\item{char}{TRUE (default) = return a character vector. FALSE = return objects of class \code{pprop}, which contain more information. NA = FALSE if \code{prop} is a singleton, TRUE if \code{prop} has more than one element.}

\item{char.method}{Which proportion approximation method to default to when \code{char = TRUE}? Possibilities are "fixed" (default) and "simple". "fixed" gives more user-friendly results, "simple" gives more exact results.}

\item{fixed.divisors}{For the "fixed" proportion approximation method, a vector of possible denominators. Only these denominators can be used in the approximation.}

\item{simple.signif.digits}{For the "simple" proportion approximation method, the number of significant digits in the denominator. Default = 1.}

\item{simple.max.num}{For the "simple" proportion approximation method, a value used in calculating the numerator. The maximum value of the numerator is approximately this, though it could be a little higher.}

\item{h}{A list of cutoffs to determine how close the proportion is to the approximate proportion. Must have the following elements: \code{eq}, \code{about}, \code{ok}. See Details for an explanation.}

\item{x}{Output of \code{pprop} when \code{char = FALSE}.}

\item{...}{Ignored.}
}
\value{
If \code{char = TRUE}, return a character vector. If \code{char = FALSE}, return objects of class \code{pprop}, which contain more information. Specifically, \code{pprop} has the following columns: 
\itemize{
	\item method: The name of the approximation method.
	\item prop: The proportion that was approximated.
	\item num, denom: the numerator and denominator of the approximation.
	\item e.prop: Decimal representation of the approximate proportion -- \code{num / denom}.
	\item es.h: Distance between the proportion and its approximation, measured using effect size h. 
	\item diff: Difference between the proportion and its approximation.
	\item ok: Is \code{es.h < h$ok}?
	\item prop.char: Approximation of the proportion, as a character. Possibly includes a descriptive prefix. When \code{char = TRUE}, this is what's returned. 
}
}
\description{
User friendly descriptions of proportions.
}
\details{
Generally, you just need to supply a proportion, or a vector of proportions, which must be between 0 and 1. The approximate proportions may contain a descriptive prefix. This prefix indicates the distance between the proportion and the approximate proportion. 

When \code{char = NA}, then consider the length of the input (and the output). If length > 1, then return just the character representations of the proportions. This allows, for example, adding a column to a data.frame with these descriptions. When length == 1, return an object of class \code{pprop}, which contains more information. 

When returning a character, use the \code{char.method} proportion approximation method. However, if that method gives an answer that is not satisfactory -- the distance between the proportion and its approximation is too high -- then use the method with the lowest distance. 

The two methods are "fixed" and "simple". In "fixed", only the denominators specified in \code{fixed.divisors} are allowed. This is the more user-friendly method, though it might not give a good approximation when the proportion is close to 0 or to 1. This can be remedied by allowing more denominators, by changing \code{fixed.divisors}.

In the "simple" method, numerators between 0 and approximately \code{simple.max.num} are allowed. Denominators have \code{simple.signif.digits} significant digits. This method is more exact but less user friendly. 

With default parameter values, the "fixed" method is used. When it does not perform well, which is near 0 and 1, the "simple" method is used automatically. 

The distance between a proportion and its approximation is measured using Cohen's h effect size. \code{h} is a list that must contain 3 elements: \code{eq}, \code{about}, \code{ok}. If h between a proportion and its approximation is less than \code{eq}, then they are so close that no descriptive prefix is used. If h is between \code{eq} and \code{about}, then the "about" prefix is used. If h is between \code{about} and \code{ok} then the "more than" / "less than" language is used. If h is greater than \code{ok}, then the approximation is considered to be too far away from the proportion. According to Cohen's rule of thumb, h < 0.20 indicates that the difference between two proportions is trivial. Therefore, by default, \code{h$ok = 0.20}.
}
\section{Methods (by generic)}{
\itemize{
\item \code{as.character}: Convert \code{pprop} object to character. For a list of \code{pprop} objects, use \code{sapply(x, as.character, char.method)}.

\item \code{as.double}: Convert \code{pprop} object to numeric. Simply returns the original proportion.
}}
\section{References}{

Cohen, J. (1988). Statistical power analysis for the behavioral sciences (2nd ed.). Hillsdale,NJ: Lawrence Erlbaum.
}
\examples{
# Basic usage
## one proportion
pprop(0.618034)	# 3 / 5
## descriptive prefix is added when necessary
pprop(0.1234)	# about 1 / 10
## default method ("fixed") does not produce
## a satisfactory answer -- switching to 
## another method
pprop(0.01234)	# about 1 / 50

## many proportions
set.seed(42)
x = data.frame(prop = runif(100))
x$desc = pprop(x$prop)
pp(x)

# Show details: char=FALSE or options(pprop.char = FALSE)
options(pprop.char = FALSE)

pprop(0.618034)	# 3 / 5 or 37 / 60
## Not as pretty
MASS::fractions(0.618034)	# 55/89

## "fixed" method does not produce a satisfactory answer
pprop(2 / 123)
## Can use the "simple" method, OR allow more divisors for the "fixed" method.
pprop(2 / 123, 
	fixed.divisors = c(getOption("pprop.fixed.divisors"), 20))

## Increasing simple.signif.digits makes results of the 
## "simple" method less pretty but more exact.
pprop(0.618034, simple.signif.digits = 2)

# compare "fixed" method, "simple" method, and MASS::fractions
options(pprop.char = TRUE)	# reset this option
x = data.frame(prop = runif(100))
x$prop.fixed = pprop(x$prop)
x$prop.simple = pprop(x$prop, char.method = "simple")
x$prop.MASS = as.character(MASS::fractions(x$prop))
pp(x)

## Above, pprop() runs twice -- once for each method.
## With a lot of data, you might want to do this, 
## which only runs pprop() once. 
x = data.frame(prop = runif(100))
pprop. = pprop(x$prop, char=FALSE)
x$prop.fixed = sapply(pprop., as.character, "fixed")
x$prop.simple = sapply(pprop., as.character, "simple")
x$prop.MASS = as.character(MASS::fractions(x$prop))
pp(x)

## All proportions from 0.0\% to 100.0\%.
n = 1000
x = data.frame(x = (0:n), n)
x$prop = x$x / x$n
pprop. = pprop(x$prop, char=FALSE)
x$prop.fixed = sapply(pprop., as.character, "fixed")
x$prop.simple = sapply(pprop., as.character, "simple")
x$prop.MASS = as.character(MASS::fractions(x$prop))
pp(x)
}
\seealso{
\code{\link[pwr]{ES.h}}, \code{\link[MASS]{fractions}}.
}
\keyword{print}
\keyword{utilities}

